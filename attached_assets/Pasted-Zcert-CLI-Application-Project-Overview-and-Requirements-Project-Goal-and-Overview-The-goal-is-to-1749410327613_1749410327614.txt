Zcert CLI Application – Project Overview and Requirements

Project Goal and Overview

The goal is to develop zcert.exe, a command-line (CLI) certificate management tool similar to Venafi’s vcert utility. This tool will interact with Venafi’s Zero Touch PKI (ZTPKI) service to perform certificate lifecycle operations (enrollment, retrieval, revocation, etc.) via the ZTPKI REST API. The zcert CLI should closely mirror vcert’s functionality and user experience, but tailored for the ZTPKI platform and its authentication method.



Environment and Context

Technology & Platform: The application will be written in Go (Golang), following the structure and coding principles of vcert (which is also Go-based). This choice allows easy compilation to a Windows executable (zcert.exe) and cross-platform support if needed in the future. Initially, the focus is on Windows usage.

CLI Framework: Use a well-supported Go CLI library (such as Cobra with Viper for config management) to handle command parsing, flags, subcommands, and configuration files. This will provide a familiar syntax (similar to kubectl, vcert, etc.) and built-in help generation.

ZTPKI Service: The tool will target the Venafi Zero Touch PKI API, specifically the provided development endpoint at https://ztpki-dev.venafi.com/api/v2. All certificate operations will be performed by calling this REST API.

Authentication: ZTPKI uses HAWK authentication (an HTTP request signing mechanism). The only credentials required (and supported) are a HAWK ID and HAWK Key pair – equivalent to an API ID and secret. Every API call from zcert must include a HAWK Authorization header. We will use a Go HAWK library (if available) or implement the HAWK protocol to sign requests.

Test Credentials: For development and testing, a HAWK ID and Key have been provided:

HAWK_ID = 165c01284c6c8d872091aed0c7cc0149

HAWK_Key = b431afc1ed6a6b7db5f760671840efa14224be60a11e0c164a6d0d021a45748c



These correspond to a test account on the dev ZTPKI endpoint.

Venafi vcert Reference: The design and functionality should mirror vcert where applicable. vcert is Venafi’s existing CLI for Venafi Trust Protection Platform (TPP) and Venafi Cloud; zcert will be analogous but focused on ZTPKI. Features like configuration file format, environment variable support, logging verbosity, and command structure should be as familiar as possible to users of vcert.

Supported Certificate Operations (CLI Commands)

The zcert tool will support multiple subcommands, each corresponding to a certificate-related operation. Initially, the core operations to implement are:



zcert enroll – Certificate Enrollment (Request new certificate)

zcert retrieve – Retrieve/Download an issued certificate

zcert revoke – Revoke an existing certificate

zcert renew – Renew a certificate (planned; initial implementation as a placeholder)

zcert search – Search or list certificates (planned; initial implementation may be basic)

Each command will have its own flags and behavior detailed below. The CLI should provide help (zcert help [command]) describing usage and flags, similar to vcert.



zcert enroll – Certificate Enrollment Workflow

This command requests a new certificate from ZTPKI, handling everything from key generation to certificate retrieval:



Policy Selection: If a Policy ID (or application/zone identifier) is not provided via CLI or config, the tool will fetch available policies from the API and present an interactive selection to the user. Using arrow keys or a menu, the user can choose which policy (certificate issuance template) to use. (The API’s /policies endpoint will be used to list policies accessible to the user.)

CSR Generation: zcert will generate a private key and Certificate Signing Request (CSR) locally. By default, it will generate an RSA key (2048-bit by default, like vcert) and create a CSR for the requested common name and any provided Subject Alternative Names. (In the future, key type/size could be customizable, e.g., RSA 4096, ECDSA P-256/P-384, etc., mirroring vcert’s options.)

The tool will support a --csr option similar to vcert: e.g. --csr local (default) means generate a new key and CSR locally. (Server-side CSR generation is not applicable for ZTPKI, so local CSR is the only mode.)

Submitting CSR: The generated CSR will be submitted to ZTPKI via a POST request to the API (likely to the /csr endpoint). This requests the ZTPKI service to issue a certificate according to the chosen policy. HAWK authentication headers must be included in this request.

Polling for Certificate: Certificate issuance may not be instantaneous. After submitting the CSR, zcert should poll or check the status until the certificate is issued. This could involve:

Polling the /certificates endpoint to see if a new certificate entry for our request appears, or

Polling a specific CSR request status endpoint (if provided by the API) or checking the response of the CSR submission for any tracking information.

Polling should have a reasonable interval and timeout, and provide feedback to the user (especially in verbose mode) that it’s waiting for issuance.

Retrieving Certificate: Once the certificate is available, zcert will retrieve it from the ZTPKI service. Likely this means calling GET /certificates with a filter or ID. The API might return the certificate (and chain) in a JSON response or possibly a PEM. The tool should handle the response format (likely JSON containing base64-encoded cert data).

Output and Storage: After obtaining the certificate, zcert will output it according to user preferences:

By default (if not specified otherwise), print the certificate in PEM format to stdout (and possibly the tool can also print the certificate chain if provided).

If an output file or format is specified, save the certificate accordingly:

PEM file: Save the certificate (and chain) as PEM-formatted files (e.g., .pem extension). Possibly also save the private key to a separate file if requested.

DER file: (Not explicitly requested, but could be supported by writing the DER-encoded cert to .der).

PKCS#12/PFX (.p12/.pfx): Save the certificate and private key in a password-protected PKCS#12 archive. (The CLI can allow a --p12-password flag or use a default like prompting the user or using a known default for testing.)

Java Keystore (JKS): Similar to PKCS#12 – store cert and key in a JKS file (requires a password and the Java keytool format). This can be an advanced feature (vcert supports JKS output).

The user can specify output format via a flag (e.g., --format pem|p12|jks etc.) and an output file path (otherwise default names can be derived from the cert CN or an ID).

If no file output is specified, stdout PEM output is the default behavior (so it can be piped or captured).

Local Key Handling: The private key generated for the CSR should be handled carefully:

If outputting to PEM, the private key can be saved to a file (e.g., <name>-key.pem) if requested by a flag (vcert often prints the key to a file when enrolling).

If outputting to PFX/JKS, the key is embedded in those and not separately saved in plaintext.

The tool should not print the private key to stdout by default, for security. It should either save it to a secure file or only output it if explicitly requested.

Config and Flags Integration: The enroll command should respect any defaults provided via config file or environment:

e.g., default policy ID, default key type/size, default common name, etc., if those are set in config or env, so the process can be non-interactive if everything is provided.

Also allow command-line flags to specify details like --policy <id> (overriding interactive selection), --cn <common-name>, --sans <alt-names>, --key-size, --key-type etc., to fully script the enrollment without prompts.

Interactive Prompts: If certain required info is missing (like no policy provided), the tool will interactively prompt the user (policy selection menu, or ask for CN if not given, etc.). Ensure these prompts only occur in an interactive session (if running in a pipeline or with all flags given, it should not pause for input).

zcert retrieve – Retrieve Certificate

This command fetches an existing certificate from the ZTPKI system, typically after it’s been issued (or for any certificate the user has access to):



Identification of Certificate: The user needs to indicate which certificate to retrieve. Possible methods:

Provide a specific certificate ID (if known) or the Certificate’s fingerprint/serial number.

Provide the Common Name (or a combination of CN and other fields) to search for a matching cert. (If multiple certs match, the tool might list matches or require a more specific identifier.)

Use a pickup ID or request ID if the API returns some identifier upon enrollment. (vcert uses a “Pickup ID” concept for Venafi Cloud – similarly, ZTPKI might provide an ID when the CSR is submitted, which can be used to retrieve the cert.)

API Call: Use the /certificates endpoint (or a specific GET /certificates/{id} if available) with the provided identifier. If using a search term like CN, we might call GET /certificates?search=<CN> (depending on API capabilities) or retrieve all and filter.

Output: Once the certificate is obtained from the API, output it in the same way as in enroll:

PEM to stdout by default or save to a file if --outfile or --format is specified, just like enroll.

If the certificate comes with a chain, include that in output (maybe combine in one file or provide separate files for chain, similar to vcert’s behavior with --chain flag).

Use Case: This command is useful for retrieving a certificate by ID or name at a later time, or to re-fetch if needed. It should also allow retrieving the certificate that was just enrolled if the user has the ID (though the enroll command automates that retrieval anyway).

Examples:

zcert retrieve --id <certificate-guid> – retrieve by explicit certificate GUID.

zcert retrieve --cn example.com --policy "<PolicyName>" – find a cert for CN "example.com" under a certain policy.

In the future, this might integrate with the search functionality (e.g., if multiple found, could list them).

zcert revoke – Revoke Certificate

This command revokes an issued certificate through the ZTPKI API:



Certificate Identification: Similar to retrieve, the user must specify which certificate to revoke. Likely by certificate ID or serial number.

API Call for Revocation: The exact API endpoint for revocation needs to be used (reference the ZTPKI swagger for a revocation call – perhaps a POST to /certificates/revoke or a DELETE on a specific certificate resource). The tool will call the appropriate endpoint with HAWK auth and the certificate identifier to perform the revocation.

Confirmation Prompt: Revoking a certificate is destructive and often irreversible. Unless a --force flag is provided, zcert should prompt the user to confirm the action (e.g., "Are you sure you want to revoke certificate CN=example.com? (y/N)").

Output: Provide feedback to the user:

On success: confirm that the certificate was revoked.

On failure: output the error returned by the API (e.g., if the cert was not found or revocation not allowed).

Logging: In debug/verbose mode, log the details of the revocation request and response for troubleshooting.

zcert renew – Renew Certificate (Future Enhancement)

The renew operation will allow obtaining a new certificate to replace an expiring one. This is slated as a future enhancement, so initial implementation will be minimal:



The command will exist and accept parameters (like an existing certificate reference), but it may simply output a message that renewal is not implemented yet or call the enroll logic behind the scenes.

Eventually, renew should:

Take an identifier for an existing certificate (could be a cert file, ID, serial, or thumbprint).

Optionally allow reusing the existing private key or generating a new one.

Submit a CSR for a new certificate (with the same subject and policy as the original, unless overridden).

Possibly integrate with ZTPKI’s way of denoting a renewal (if the API has a special endpoint or just uses the same CSR submission flow).

The output would be a new certificate (just like enroll) which the user can use to replace the old one.

Placeholder Implementation: For now, the zcert renew command can be stubbed out or simply call enroll under the hood with appropriate parameters, until full renewal logic is developed. We include it so that the CLI structure is ready and users can see that renew is planned.

zcert search – Search/List Certificates

The search command allows users to find certificates and list them:



Basic Listing: With no filters, zcert search can retrieve all certificates accessible to the user (using GET /certificates API). This may return a list of certificate metadata (likely a list of certificate entries in JSON). The tool can format this in a readable way (table or list of common names, IDs, expiration dates, etc.).

Search Filters: Although not fully implemented initially, the design should anticipate filters such as:

--cn <name> to search by common name (or substring).

--serial <serial-number> to find a specific certificate.

--expires-before <date> or --expires-after <date> to find certificates expiring in a certain window.

Possibly --policy <policy-id> to filter by issuing policy.

(These would correspond to query parameters or client-side filtering depending on what the API supports natively.)

Pagination: If the number of certificates is large, handle pagination from the API or at least warn the user. (For initial implementation, this might be ignored or simplified.)

Output Format: For human readability, format the search results in a concise table (e.g., columns for Certificate ID, Common Name, Expiry, Status). Optionally, provide a flag to output raw JSON for scripting.

Initial Implementation: The first version may implement only a simple form of search (e.g., list all certificates, or require the user to provide a specific search filter and then just display matches). The advanced filtering is marked as a future enhancement.

Configuration Options

zcert should be configurable via both configuration files and environment variables, in addition to CLI flags. This provides flexibility in how the user supplies necessary information.



YAML Configuration File: Support a config file (e.g., zcert.yaml) that can store default settings. This is similar to how vcert can use a config file to avoid repeatedly typing common parameters.

Config Contents: The YAML file can include sections/keys for:

Connection/Authentication: e.g., url (ZTPKI API URL), hawk_id, hawk_key, etc.

Defaults for Requests: e.g., default policy_id to use, default key_type or key_size, default format for output, etc.

Certificate Details: possibly default subject details like common_name or an array of sans if the use-case is consistent.

Output/Environment: e.g., an output directory for certificates, or default verbosity level.

Logging: e.g., a flag or level for debug mode by default.

File Location: By default, zcert can look for zcert.yaml in the current directory and the user’s home directory (similar to how vcert might look for a config). We can also allow specifying a custom config file via a flag (e.g., --config path/to/file.yaml).

Compatibility: The structure should be inspired by vcert’s config to include all relevant sections, adjusted for ZTPKI specifics. For example, vcert’s config for Venafi Cloud might have an api_key field; in our case, we’ll have hawk_id and hawk_key instead. We want existing users to find the config intuitive.

Environment Variables: The tool should recognize environment variables for all key parameters to facilitate non-interactive use (scripts, CI/CD):

ZCERT_HAWK_ID and ZCERT_HAWK_KEY – credentials for authentication.

ZCERT_URL – base URL of the ZTPKI service (optional, default to production or the provided dev URL for testing).

ZCERT_POLICY_ID – default policy to use for enrollment if not specified.

ZCERT_FORMAT – default output format, etc.

Environment variables allow secure credential injection and can override or serve in place of config file values.

Precedence: Typically, CLI flags have highest precedence, then environment variables, then config file defaults. (This ensures that a user can override config with a command-line switch when needed.)

Examples:

A user could set env vars ZCERT_HAWK_ID and ZCERT_HAWK_KEY in their shell, so they don’t need to pass credentials on every command.

They could have a zcert.yaml with a default policy_id and format: pem so that running zcert enroll --cn example.com is enough to enroll a cert with that policy and get a PEM output.

CLI Behavior and User Experience

Subcommands & Flags: Utilize Cobra to define subcommands (enroll, retrieve, etc.) each with its specific flags. Ensure the CLI outputs useful help messages. For example, zcert enroll --help should list flags like --policy, --cn, --csr, --key-type, --outfile, etc., with descriptions.

Interactive Features: The CLI should gracefully handle interactive scenarios:

The policy selection menu (if needed) will use an interactive prompt package (such as survey or Cobra’s built-in prompt support) to list available policies by name. The user can scroll or type to select one. Include policy names and maybe IDs for clarity.

If information like Common Name is missing, prompt the user to input it (unless running in a non-interactive mode).

Output Messages: Provide clear and user-friendly messages:

On successful enrollment, something like: “Certificate for CN=example.com successfully issued. Saved to example.com.pem” (or printed to console).

On errors, catch common issues (e.g., authentication failure, policy not found) and display helpful messages rather than raw errors. Possibly suggest running with --debug for more details if an error is not obvious.

Examples and Documentation: Aim to include usage examples in documentation or --help output. (E.g., show how to enroll a cert in one command with all flags vs. interactively.)

Logging and Debugging

The application should support adjustable verbosity for troubleshooting and insight:



Quiet by Default: By default, zcert should output minimal information (typically just the end result or essential prompts/errors). This is important for scripting use so that the output (like the certificate) isn’t cluttered.

Debug/Verbose Mode: If the user specifies --debug (or perhaps -v or --verbose), the tool will produce more detailed logs about its operation. Potential levels:

A single --debug flag could enable a reasonable level of detail (e.g., showing what API endpoints are being called, response statuses, etc.).

If needed, we could introduce multiple levels (like --verbose vs --debug or --debug=2 for even more detail), but initially one level is fine.

Debug Output Content: In debug mode, log information such as:

The full URL of API requests and the type of request (GET/POST).

The payloads being sent (CSR submission details, etc.) – but do not log sensitive data such as the HAWK Key or private keys.

Responses from the API (status codes, maybe response body if not too large).

Decisions made (e.g., “No policy provided, fetching policies for selection”, “Selected policy: PolicyName (ID)”, “CSR generated with key type RSA-2048”, etc.).

Steps in polling (“Certificate not ready yet, checking again in 5 seconds...”, “Certificate issued, proceeding to download”).

Error Details: If an operation fails (non-200 HTTP response or an exception), debug mode should output any error details returned by the API (e.g., error messages or codes). This helps in troubleshooting issues with the ZTPKI service or usage.

Logging Implementation: This can be done with Go’s logging package or Cobra/Viper’s inbuilt capabilities. We might define a global log level and a custom logger that respects the verbosity setting.

Internal Structure and Development Notes

To maintain consistency with vcert and ease future enhancements:



Project Structure: Organize the code with clear separation of concerns:

e.g., a package for API interactions (network calls, authentication signing), a package for handling certificate & key generation (CSR logic), and the cmd package for CLI command definitions.

Mirror vcert’s packages if possible (vcert has packages like pkg/certificate, pkg/endpoint, etc.). For instance, implement a ztpkiConnector similar to vcert’s connectors for TPP/Cloud.

HAWK Authentication: Use a reliable Go library for HAWK (if one exists) to handle creating the HAWK Authorization header. This ensures we correctly generate the MAC using the HAWK Key, timestamp, nonce, and request details. If no library is suitable, implement according to HAWK specs.

The HAWK credentials (ID and Key) will be plugged into this auth mechanism for each HTTP request. The HAWK ID typically goes in the header along with a MAC that is a hash (HMAC) of parts of the request using the HAWK Key.

Each request must include: a timestamp (and maybe a nonce) – the tool should manage these (the HAWK library will handle most of it). The user should not need to worry about it.

HTTP Client: Use Go’s net/http or a higher-level library (like resty) for making API calls. Handle TLS (the dev endpoint is HTTPS) – ensure it’s using system CAs or provide a way to trust custom CAs if needed.

Testing: Plan to create tests as features are implemented. For example:

Test the HAWK authentication header generation with known values.

Test CSR generation (ensure a CSR can be parsed and contains the expected subject/CN).

Possibly simulate API responses (using a mock server or recording actual calls to the dev environment for known inputs).

Because we have dev credentials, a manual integration test can be done against the dev environment to confirm enroll/retrieve flows.

Windows Considerations: Since targeting Windows, ensure file paths and default file locations are Windows-friendly (e.g., use %APPDATA% or the current directory for config if appropriate). Also, if packaging, ensure the .exe is easily runnable. (Go makes cross-compiling easy if needed.)

Future Proofing: Keep the design flexible so new subcommands or backends could be added (e.g., if later we wanted zcert to talk to a different endpoint or support other auth, it should not be hard-coded in a single monolithic function).

Future Enhancements and Placeholders

In addition to the immediate functionality, some features are recognized for future implementation. Placeholders or basic structures will be included now to accommodate these enhancements later:



Full Certificate Renewal Logic: The renew command will be expanded to intelligently renew certificates. This might involve retrieving the old certificate’s details, creating a new CSR (possibly using the old key or a new key), and indicating to ZTPKI that this is a renewal (if that context is needed). For now, the command exists but with minimal implementation.

Advanced Search Filters: As noted, the search functionality will grow to accept various filters. In the initial version, the groundwork (command structure and maybe one simple filter) will be there, but more advanced filtering and formatting of results will come later.

Certificate Validation: Introduce a utility to validate a certificate or certificate chain. This could be a separate command (e.g., zcert validate <cert-file>), or part of the enroll/retrieve process (to double-check the certificate content after retrieval). Validation would include:

Parsing the certificate to ensure it’s well-formed.

Verifying the signature chain (if a chain is provided, and if we have access to the issuing CA certificate).

Checking expiration and maybe if the certificate matches the CSR (public key comparison).

Possibly checking revocation status via CRL or OCSP (though that might require network calls to the CA’s revocation endpoints, which is beyond ZTPKI’s scope).

This is a future feature; a placeholder function might simply parse the PEM to confirm it's a valid X.509 certificate for now.

Policy Management: In the future, we might add commands to manage or inspect policies (for example, list available policies without having to do it only during enrollment). Since the API has a /policies endpoint, a zcert list-policies command could be added later. Currently, policies are accessed interactively in enroll, but exposing this as its own command could be useful for scripting (this is an enhancement idea).

Bulk Operations: Though bulk operations (handling multiple certificates in one command) are not needed now (explicitly not needed per requirements), we leave room if later needed (like renewing all certs expiring in 30 days, etc.).

Improved Logging Levels: Possibly add more granular log levels (info, warning, error, debug, trace). The framework will be set such that adding a --trace that logs raw HTTP requests/responses, for example, would be feasible in the future.

Cross-Platform Distribution: While Windows is the current focus, ensure that building for Linux/Mac is not hindered. In the future, official releases for other OS could be provided if needed by users.

User Feedback Integration: As the tool gets used, future updates might incorporate user feedback (for example, additional convenience flags, more robust error messages, config enhancements). Keeping the code modular will ease these changes.

Conclusion

This prompt summarizes the requirements and context for the zcert CLI application. It covers the objectives (building a vcert-like tool for ZTPKI), the technical environment (Go, Cobra CLI, HAWK auth to ZTPKI API), detailed behaviors of each command, configuration and auth handling, as well as both immediate tasks and future enhancements. Any AI or developer using this prompt should have a clear understanding of what the zcert tool is supposed to do and how it should behave, providing a solid foundation for either implementation or further design discussions.