Sprint 1 – Core Playbook Execution
Objective: Implement the basic vcert run command workflow, focusing on parsing the YAML and performing a single certificate enrollment and installation in PEM format. Scope & Tasks:
Command Parsing: Add the run subcommand to the CLI. Use Go’s flag parsing to handle --file (with default ./playbook.yaml) and --force-renew options. Ensure the command appears in the vcert --help menu and has its own help description.
YAML Parsing: Utilize a YAML library (e.g. Go’s gopkg.in/yaml.v3) to read the specified playbook file into the internal data structures. Define structures for Config, CertificateTask, Request, Installation, etc., matching the schema (as outlined above)
pkg.go.dev
pkg.go.dev
. Include support for environment variable interpolation. For this, integrate a lightweight templating step so that strings like {{ Env "VAR" }} are replaced with their os.Getenv("VAR") value
gist.github.com
 before or during parsing.
Basic Validation: After parsing, validate the playbook content. Leverage the IsValid() methods provided in the SDK for Playbook, Config, CertificateTask, Installation etc. to ensure required fields are present
pkg.go.dev
pkg.go.dev
. For example, each CertificateTask must have a zone and subject.commonName in the request, each Installation must have a valid file path or store location, etc. If validation fails, return a clear error to the user (and exit with non-zero status).
Certificate Enrollment (Core): Implement logic to perform a certificate request for each task:
Initialize a Venafi connection client using the config (platform type, credentials, URL, trust bundle). This uses the existing VCert Go SDK client (e.g. vcert.NewClient(config)).
Build a certificate request object from the task’s request fields (using certificate.Request from the SDK). Include CSR generation if csr: service (the Venafi platform will generate key/CSR server-side), or handle local CSR if that option is used (out of scope for Sprint 1 if focusing on service generation).
If --force-renew is not set, check for an existing certificate on disk from a previous run (e.g. if the target cert file exists). If present, examine its expiration. Use the renewBefore policy: calculate if the cert is within the renewal window (e.g. within X days of expiry or past Y% of lifetime). This may require parsing the cert (e.g. via Go’s x509 library) to get dates. If the certificate is still valid beyond the threshold, skip the request (log that it’s not due for renewal). If --force-renew is set, always perform the request, ignoring any existing certificate
github.com
.
Call the SDK to request the certificate. Handle the asynchronous nature if applicable (Venafi Cloud may issue immediately or require polling). For simplicity, use the blocking enrollment (the SDK will handle waiting for issuance if needed).
Installation (Core PEM): Once a certificate (and private key, if locally generated) is obtained, install it to the specified location(s). In Sprint 1, implement at least the PEM file installation:
Write the certificate to file path in PEM format. If a chainFile is specified, write the issuing CA chain to that path. If keyFile is specified and a local key was generated by VCert, write the private key to that path (with proper file permissions).
If backupFiles: true, and files already exist at those paths, create backups (e.g. copy to *.bak or timestamped filename) before overwriting.
If an afterInstallAction is provided, execute it using the OS shell. This could be done via os.Exec or spawning a subprocess. Capture the result; if the command fails (non-zero exit), log a warning or error. (In Sprint 1, we can log and continue, or decide to treat it as a non-fatal issue – to be refined in testing.)
Logging & Feedback: Provide console output to inform the user of progress. At minimum, log each major step: e.g., “Connecting to Venafi Platform…”, “Requesting certificate for [Common Name]…”, “Certificate retrieved (ID: …), installing to …”, “Installation complete”. If skipping due to renewBefore logic, inform “Certificate not due for renewal; skipping request.” Use an appropriate logging level (info vs. error). For Sprint 1, simple fmt.Println or standard log is acceptable.
Unit Tests (Sprint 1): Begin creating a suite of unit tests for core functionality:
YAML Parsing & Validation: Provide a sample minimal YAML (inline or as a testdata file) to the parser and verify that the resulting Go struct has expected values. Include a test case for a missing required field (e.g. omit zone) to ensure validation catches it.
Renewal Logic: Simulate an existing certificate scenario. For test purposes, generate a dummy certificate file with a known expiration date. Then run the renewal check logic with a given renewBefore (e.g. set renewBefore: 1d and use a cert that expires far in the future) and assert that the function decides to skip renewal. Conversely, test that it would renew if within window. (This can be done by exposing a small function that evaluates the timestamps given a renewBefore string.)
PEM Installation: Use a temporary directory in tests. After obtaining a dummy cert/key (the Venafi SDK can be stubbed or we supply test PEM data), call the installation routine to write files. Verify that files are created with correct contents. Test backupFiles by pre-creating dummy files, running installation, and checking that backups exist and new files have updated content.
AfterInstallAction: To test this without side effects, use a harmless command (like echo on Linux or a no-op script) and ensure that it runs. Alternatively, mock the command execution function to assert it was called.
Definition of Done (Sprint 1): The vcert run command can successfully process a playbook with one certificate task using Venafi Cloud or TPP (with valid credentials), enroll a certificate, and save it as PEM. Unit tests cover YAML parsing and a basic enrollment/installation flow. Running vcert run -f myplaybook.yaml on a sample YAML should result in a new certificate file on disk (or a skipped renewal if already up-to-date). Basic help and usage information for the command is in place and correct.